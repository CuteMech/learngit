堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 
堆栈(Stack，亦译作"栈")是一种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。

cin遇到空格tab回车都会结束接受字符串输入 char*
std::ostream_iterator<type>(std::cout, " "));每次写操作后写入""中的分隔字符串。
cctype
isalnum字母数字	isalpha字母	isdigits数字
isspace空白	ispunct该字符是否是标点
decltype(a) b 定义b和a同类型
toupper(s) 返回字符串s的大写(可s[k]只改变其中一个字符), for( auto &c : s)

常对象 常成员函数 友元函数 友元类

深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。
深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。
浅拷贝无需额外写一个
	A(const A& _A) : size(_A.size)
	{
		data = new int[size];
	} // 深拷贝 

继承派生
protected继承比private多一项 派生类的成员函数可以访问当前对象的基类的保护成员
执行派生类构造函数之前, 先执行基类的构造函数；
构造函数名(形参表): 基类名(基类构造函数实参表){}	基类构造函数显式则派生类也要显式

运算操作符重载
const类型间接地不可改变；const类型不可被非const类型的指针指向
labs()长整形取绝对值
赋值运算符重载时，返回值设为其所作用的对象的引用，是符合赋值运算符使用习惯的做法
atoi(str) 将字符串str上的数字变int输出；如果str中的非空白字符的第一个序列不是有效的整数，或者由于str为空或仅包含空白字符而没有这样的序列，则不执行任何转换并返回零。
c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float

Defined in header <cstring>		
void* memcpy( void* dest, const void* src, std::size_t count );
	
函数模板
C++编译器遵循以下优先顺序:
Step 1: 先找参数完全匹配的普通函数(非由模板实例化而得的函数)
Step 2: 再找参数完全匹配的模板函数
Step 3: 再找实参经过自动类型转换后能够匹配的普通函数
Step 4: 上面的都找不到, 则报错
string特性看下载的PPT

原则：类模板，模板类是类模板的实例
类模板派生出类模板；模板类 (即类模板中类型/非类型参数实例化后的类)派生出类模板
普通类派生出类模板；模板类派生出普通类.
从类模板不可直接派生出普通类，要先产生实例才可
B<char>obj1 为类模板
template<class T>
	class B{ };  的实例化

STL笔记
容器.resize() www.cplusplus.com/reference/vector/vector/resize/
.front()访问“容器”或“迭代器”的“第一个元素”,back()就是访问容器的最后一个元素
1. map、set、list、vector、deque这五种容器中，有几种是排序的？
2种(map和set)
2. 下面5种操作，有几种时间复杂度一定是常数的？2种(O(N))
(1)在vector尾部增删元素√
(2)在关联容器中查找元素 O(log(N))
(3)在list中的某一位置增删元素√
(4)随机访问vector中的元素 (存取才是O(N))
(5)在multimap中插入元素O(log(N))

顺序容器
vector 随机访问
deque 随机访问
list 双向
关联容器
set/multiset 双向
map/multimap 双向

find() 输出迭代器 find在[first,last)查找等于val的元素；找到，则该迭代器指向被找到的元素；找不到，则该迭代器等于last
str.find("+", 0);从下标0开始

先语法，看书，做基本练习
再算法，基本的练到一定程度可以加入竞赛（如力扣）
