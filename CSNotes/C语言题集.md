## 问题1：请写出以下程序的输出结果。

    int main()
    {
        int a[5]={1,2,3,4,5};
        int *ptr=(int *)(&a+1);
        printf("%d,%d\n",*(a+1),*(ptr-1));
    }
【分析】：此题需要理解指针和数组的内在含义。
【结果】：2,5

【理论知识】：我们首先需要搞明白a,&a.

a既是数据名，又是指向数组第一个元素的指针。

sizeof(a)=20, 此时a的类型为int[5]数组。

sizeof(*a)=4，因为有取值符*，表示把a当成一个指针(int*)，而a指向数组的首地址，

即a=&(a[0])，即sizeof(*a)=sizeof(*&(a[0]))=sizeof(a[0])=sizeof(int)=4。

*(a+1)中把a当成一个指针，a+1=a+sizeof(int)，a+1指向a的下一个整形地址既&a[1]。

因此*(a+1)=*(&a[1])=a[1]=2。

(&a + 1)先取变量a的地址，并根据a的地址获得下一个与a同类型的相邻地址。根据前面所说的a的类型为int[5]数组。

&a+1=&a+sizeof(5*int)，因此&a+1指向的地址为&a[5](数组a[5]的下一个地址)。

(int*)(&a + 1)把这个相邻地址显式类型转换为int类型的地址int *ptr = (int*)(&a + 1); 

所以ptr指向&a[5]，并且ptr是一个int类型的指针。

ptr-1=ptr-sizeof(int)，故ptr-1指向&a[4]。因此，*(ptr-1)的值即为a[4]=5。

【个人理解】：

a[5]即可以看成是一个一维数组，也可以看成是一个只有一行的二维数组a[1][5]。

所以a指向一维数组的首地址，即a=&a[0]，a+1指向&a[1]。每次加的地址长度为sizeof(int).

而&a指向二维数组的首地址,即&a=&a[0][5]，&a+1指向&a[1][5]。每次加的地址长度为sizeof(5*int).
————————————————
版权声明：本文为CSDN博主「杰Tang_fighting」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jjjcainiao/article/details/20608039

## 问题2 下面的c程序在输入tt 12 345 678后结果是什么？
    main(int argc,char *argv[])
    {   int n=0,i;
        for(i=1;i<argc;i++)
        n=n*10+*argv[i]-'0';
        printf("$d\n",n);
        getch();
    } 

136
该题考察的是main函数，C编译器允许main()函数没有参数，或者有两个参数（有些实现允许更多的参数，但这只是对标准的扩展）。这两个参数，一个是int类型，一个是字符串类型。第一个参数是命令行中的字符串数。第二个参数是一个指向字符串的指针数组。
命令行中的每个字符串被存储到内存中，并且分配一个指针指向它。按照惯例，这个指针数组被称为argv（argument value）。系统使用空格把各个字符串格开。一般情况下，把程序本身的名字赋值给argv[0]，接着，把参数第一个字符串赋给argv[1]
12 345 678是以字符串的形式输入的，*argv[i]表示取第i个参数的首字符
argv[0]  ------>   c(程序名)
argv[1]  ------>   1
argv[2]  ------>   3
argv[3]  ------>   6
  第一次循环：n=0*10+'1'-'0'= 1
  第二次循环：n=1*10+'3'-'0'=13；
  第三次循环：n=13*10+'6'-'0'=136

## 问题3 定义问题
    #include "stdio.h"
    #define f(x) x*x
    int main()
    {
        int a=6,b=2,c;
        c=f(a)/f(b);
        printf("%d\n",c);
        return 0;
    }
//c=f(a)/f(b); 实际上在预编译时把f(x)直接du用x*x替换了，zhic=a*a/b*b，c=6*6/2*2=36,是不会加括号的dao，要自己加括号#define f(x) ((x)*(x))