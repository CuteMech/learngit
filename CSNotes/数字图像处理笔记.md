vc8 = Visual Studio 2005，vc9 = Visual Studio 2008，vc10 = Visual Studio 2010，vc11 = Visual Studio 2012，vc12 = Visual Studio 2013，vc14 = Visual Studio 2015 <br>
图像动态范围的上限∝饱和度，下限∝噪声；比特数;
1、采样频率高于信号最高频率的两倍，这种采样被称为过采样。<br>
2、采样频率低于信号最高频率的两倍，这种采样被称为欠采样。

cyan青色 Magenta品红
OpenCV  通道交换，转灰度公式，大津二值化算法，减色处理一致减少色彩等级

平均池化，最大池化(Pooling) 按照网格分割取同“池子”内的为相同的数值，像是打马赛克 <br>
直方图归一化即按照灰度值(或RGB)大小相应倍数扩大；亦有变更直方图平均值和标准差的方法；以上二种均能使图像变得更清晰 <br>
常用的RGB坐标一共有256x256x256=16777216种，这样横坐标过多，而且很多横坐标对应的像素点数量很少，整个直方图会很稀疏。<br>
因此将颜色空间划分为若干个小的颜色区间，对于每个颜色通道（R,G,B），每32个划分到一个bin里面，这样每个颜色通道就有8bins，也就是每个颜色通道只能取8个值了，那么由排列组合知，取法一共有8^3=512种。<br>
问题：直方图均衡化色彩变得更艳丽，为什么？答：或许是因为使得色彩的分布更广。<br>
纵横比（Aspect Ratio）<br>
维基百科图解**卷积**定义：两函数交会时，计算交会范围中两函数乘积的积分值。见图

![File:Convolution3.svg](https://upload.wikimirror.org/wikipedia/commons/thumb/7/79/Convolution3.svg/530px-Convolution3.svg.png)

 滤波步骤：

    1.对原始图像的边缘进行某种方式的填充（一般为0填充）。
    2.将掩膜划过整幅图像，计算图像中每个像素点的滤波结果。

卷积步骤：

    180度翻转卷积核。
    不做边界填充，直接对图像进行相应位置乘积和。

从以上步骤可以看出，如果卷积核不是中心对称的，那么卷积和滤波操作将会得到完全不一样的结果。另外，卷积操作会改变图像大小！<br>
由于卷积操作会导致图像变小（损失图像边缘），所以为了保证卷积后图像大小与原图一致，经常的一种做法是人为的在卷积操作之前对图像边缘进行填充。<br>
最后，关于卷积后图像尺寸的计算：假设原始图像为M×M，卷积核大小为N×N，边缘填充像素个数为pad，步长为stride。则卷积后图像的尺寸变为：m =(M-N+2×pad)/sride+1。

腐蚀与膨胀: 膨胀和腐蚀被称为形态学操作。它们通常在二进制图像上执行，类似于轮廓检测。通过将像素添加到该图像中的对象的感知边界，扩张放大图像中的明亮白色区域。侵蚀恰恰相反：它沿着物体边界移除像素并缩小物体的大小。

![image](https://upload-images.jianshu.io/upload_images/8789591-d7df75e79e9d3058.png?imageMogr2/auto-orient/strip|imageView2/2/w/849)

双线性插值 Bilinear Interpolation
$$
d_x = \frac{x'}{a} - x\\  d_y = \frac{y'}{a} - y\\  I'(x',y') = (1-d_x)\  (1-d_y)\  I(x,y) + d_x\  (1-d_y)\  I(x+1,y) + (1-d_x)\  d_y\  I(x,y+1) + d_x\  d_y\  I(x+1,y+1)
$$
学习累计：高斯滤波；sobel算子和sobel的替代算子charr，后者结果更加精确(边缘检测)，摩尔投票算法，霍夫变换，模板匹配

## API

图像处理API地址 D:\Software\openCV3.1.0\opencv\sources\modules\imgproc\src
cv::resize() 放大图像时涉及选择何种插值问题；cv::solve(  ,DECOMP_SVD)  奇异值分解(SVD)；dot() 点乘；<br>
cvRound(), cvFloor(), cvCeil() 四舍五入 取小 取大； glob()遍历文件夹的图片<br>
CV_PI即Pi    Keypoint类<br>
Point(x,y)  Matclass.at<typename>(y,x)  零点默认在左上角<br>
saturate_cast<uchar> 这个函数的功能是确保像素值在uchar类型数据允许范围之内；convertScaleAbs()图像变8位，convertTo()矩阵变任意位 <br>
putText(InputOutputArray  	img,  
		const String &  	text, 
		Point  	org, 
		int  	fontFace, 
		double  	fontScale, 
		Scalar  	color, ...) 将文字嵌入图像中 <br>
        
imshow可正常显示灰度图，但是imwrite存入的时灰度图是黑色。
原因可能是因为图片的格式问题，因为如果图片格式是float或者是double这些，图片的灰值被归一化到了[0,1]的范围，但是imwrite必须是[0,255]的范围
具体解决办法
1.可以通过将图片的格式改为uint8格式
2.将你的图片乘以255(可在用Mat新建变量时候直接乘以)

cv::imread()除了不支持单右斜线形式，其他斜线形式都支持，比如双右斜线形式、双左斜线形式、单左斜线形式、前述三种斜线混合型式均支持(如下)。这么做的原因是单右斜杠是转义符，多数IDE中都有此种情况

     //-- 1 --双右斜线法  
    //string imgpath = "C:\\Users\\bingbuyu\\Pictures\\photo\\miao1.jpg";  
    //-- 2 --双左斜线法  
    //string imgpath = "C://Users//bingbuyu//Pictures//photo//miao1.jpg";  
    //-- 3 --单左斜线法  
    //string imgpath = "C:/Users/bingbuyu/Pictures/photo/miao1.jpg";  
    //-- 4 --以上三种混合法  
    //string imgpath = "C:/Users//bingbuyu\\Pictures//photo//miao1.jpg";  
    //-- 5 --相对路径法  
    //string imgpath = "miao.jpg";  
    //-- 6 --命令行参数法  
    //string imgpath = argv[1];
    ./ 是当前目录
    ../是父级目录
    /  是根目录

OpenCV-python 
.shape()读取矩阵行列数 
W_update=np.zeros_like(W);函数主要是想实现构造一个矩阵W_update，其维度与矩阵W一致，并为其初始化为全0；这个函数方便的构造了新矩阵，无需参数指定shape大小； 
直方图matplotlib.pyplot里的hist()  histgram

## 高斯函数是正态分布的密度函数

问题1：高斯滤波模板是什么？3×3和5×5分别适用于什么条件？是怎么的出来的？
答：高斯滤波器是一种线性滤波器，能够有效的抑制噪声，平滑图像。其作用原理和均值滤波器类似，都是取滤波器窗口内的像素的均值作为输出。其窗口模板的系数和均值滤波器不同，均值滤波器的模板系数都是相同的为1；而高斯滤波器的模板系数，则随着距离模板中心的增大而系数减小。所以，高斯滤波器相比于均值滤波器对图像个模糊程度较小。 
钟型曲线在区间(μ+σ,μ+σ)范围内的面积占曲线下总面积的68%，(μ+2σ,μ+2σ)范围占95%，(μ+3σ,μ+3σ)范围占99.7%，一般3σ外的数值已接近于0，可以忽略，通常程序只计算(6σ+1)×(6σ+1)就可以保证相关像素影响。 高斯模糊线性可分。 <br>

通过将图像与高斯函数进行卷积得到一幅图像的低通滤波结果，即去噪过程。 
矩阵{[-1 -2 -1],[0 0 0],[1 2 1]}按照行(row)排

一些问题：
1.为什么构建尺度空间的时候要把图像转换为0-1之间的浮点数据？
答：将它归一化主要是便于计算，加快收敛，你想0-1和0-255的数据当然是0-1容易计算。
如果对输出结果范围有要求，归一化；如果数据较为稳定，不存在极端的最大最小值，用归一化；如果数庭存在异常值和较多噪音，用标准化，可以间接涌过中心化邂免异帛值和极端值的影响

2.尺度空间层数是不是就是金字塔的层数？核宽度为什么是2*size+1？
3.ROEWA滤波核半径=尺度 *2 ; 核宽度为什么是 2 * size+1？

霍夫变换即通过边各种变换找直线

用仿射变换(旋转后平移)而不是直接旋转是因为Mat对象坐标原点在左上角

卷积的意义：加权叠加

超平面定义：
(1) 超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。(比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。)
(2) 法向量是指垂直于超平面的向量。


## Harris角点检测

在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点 cornerHarris()

来源：
https://www.cnblogs.com/Jack-Elvis/p/11640931.html https://www.cnblogs.com/polly333/p/5416172.html
trace 方阵对角线元素的和。 
det 方阵的行列式 
通过Harris矩阵 M的两个特征值λ1和λ2的大小 对图像点进行分类：

![img](https://images2015.cnblogs.com/blog/451660/201604/451660-20160421110545991-444695518.png)

如果λ1和λ2都很小，图像窗口在所有方向上移动都无明显灰度变化。R取决于M的特征值，对于角点|R|很大，平坦的区域|R|很小，边缘的R为负值。
由于我们是通过M的两个特征值的大小对图像进行分类，所以，定义角点相应函数R：

![img](https://images2015.cnblogs.com/blog/451660/201604/451660-20160421110704554-1638377066.png)

其中k为经验常数，一般取k=0.04~0.06。为了去除加权常数κ，我们通常使用商数detM/(traceM)^2作为指示器。所以，上图可以转化为：

![img](https://images2015.cnblogs.com/blog/451660/201604/451660-20160421110717679-75867209.png)

R只与M的特征值有关。
角点：R 为大数值正数；
边缘：R 为大数值负数；
平坦区：R 为小数值<br>
在判断角点的时候，C对角点响应函数R进行阈值处理：R > threshold，提取R的局部极大值。

## SIFT

    尺度空间中各尺度图像的模糊程度逐渐变大，能够模拟人在距离目标由近到远时目标在视网膜上的形成过程。
    尺度空间变换：通过模仿人眼识别的方式，认识图像，寻找特征......
    尺度越大图像越模糊。
    兴趣点描述子是分配给兴趣点的一个向量，描述该点附近的图像的表观信息。描述子越好，寻找到的对应点越好。我们用对应点或者点的对应来描述相同物体和场景点在不同图像上形成的像素点。

参数σ，在Sift算子中取的是固定值1.6，σ即尺度/模糊系数

第一步：根据输入图像大小计算高斯金字塔的组数

第二步：先将原图像扩大一倍(边长×2面积×4)之后作为高斯金字塔的第1组第1层，将第1组第1层图像经高斯卷积
		高斯金字塔的构建将第1组倒数第三层图像作比例因子为2的降采样...(在最开始建立高斯金字塔时，要预先模糊输入图像来作为第0个组的第0层的图像，这时相当于丢弃了最高的空域的采样率。因此通常的做法是先将图像的尺度扩大一倍来生成第-1组。)
		最终
		在同一组内，不同层图像的尺寸是一样的，后一层图像的高斯平滑因子σ是前一层图像平滑因子的k倍；
		在不同组内，后一组第一个图像是前一组倒数第三个图像的二分之一采样，图像大小是前一组的一半；
		
第三步：尺度空间
		以高斯金字塔的组O作为二维坐标系的一个坐标，不同层L作为另一个坐标，则给定的一组坐标（O,L）就可以唯一确定高斯金字塔中的一幅图像。
		
第四步：DOG 生成高斯金字塔的目的就是为了构建DOG金字塔。

第五步：特征点检测
    关键点精确定位，曲线插值(最小二乘法，奇异值矩阵)，矩阵Taylor展开，
    删除：
特征点方向的偏移量过大 定位在边界区域的特征点 关键点精确插值迭代次数未满满足5次 特征点响应低的点 边缘响应较强的点； 
最后保存剩下的点

对于每一个关键点，拥有三个信息：位置、尺度以及方向。为每个关键点建立一个描述符，使其不随各种变化而改变，如光照变化、视角变化等。且描述符应有较高独特性，以便于提高特征点正确匹配的概率。

这篇检测极值点的比较好https://www.cnblogs.com/Jack-Elvis/p/11297216.html <br>
Hessian矩阵是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵<br>

LBP局部二值模式是一个简单但非常有效的纹理运算符。它将各个像素与其附近的像素进行比较，并把结果保存为二进制数。<br>

	int nfeatures;//设定检测的特征点的个数值,如果此值设置为0，则不影响结果 
	int nOctaveLayers;//每组金字塔中间层数 3
	double contrastThreshold;//对比度阈值（D(x)方差=0.04）
	double edgeThreshold;//特征点边缘曲率阈值 10
	double sigma;//高斯尺度空间初始层的尺度 1.6
	bool double_size;//是否上采样原始图像 1

混淆现象（Aliasing）指图像中非直线（斜线）线条出现的锯齿现象，例如圆形的边缘。锯齿清晰可见，放大后尤其明显<br>
消除锯齿:锯齿没那么明显，线条看上去更平滑<br>
线性插值是一种使用线性多项式进行曲线拟合的方法，可以在一组离散的已知数据点范围内构造新的数据点。

05/09 晚上利用三角函数知识 求证了 关键点描述中 将坐标移至关键点主方向的旋转角度后新坐标公式

## 改变描述子

纹理特征：纹理是一种反映图像中同质现象的视觉特征，它体现了物体表面的具有缓慢变化或者周期性变化的表面结构组织排列属性。<br>
纹理滤波：在计算机图形学中，纹理滤波（Texture filtering）是一种针对一个使用材质贴图的像素，使用临近的一个或多个纹素计算其纹理颜色的方法。从数学上来说，纹理滤波是抗锯齿的一种，但它更着重于滤掉纹理中的高频，而不像其他抗锯齿技术那样着重于改善边界显示效果。简单来说，它使得同一个纹理可以被用于不同的形状，尺寸和角度，同时尽可能减少显示时的模糊和闪烁。<br>
Gabor滤波器:在图像处理中，以Dennis Gabor命名的Gabor滤波器是用于纹理分析的线性滤波器，它基本上分析了点或区域周围的局部区域中特定方向上图像中是否存在特定频率成分分析。<br>
 Gabor滤波器的脉冲响应，可以定义为一个正弦波（对于二维Gabor滤波器是正弦平面波）乘以高斯函数。由于乘法卷积性质，Gabor滤波器的脉冲响应的傅立叶变换是其调和函数的傅立叶变换和高斯函数傅立叶变换的卷积。该滤波器由实部和虚部组成，二者相互正交。一组不同频率不同方向的Gabor函数数组对于图像特征提取非常有用。
二维Gabor函数的数学表达见维基百科 http://en.wikipedia.org/wiki/Gabor_filter <br>
在这个方程中，λ表示正弦因子的波长，θ表示Gabor函数的法向平行条纹的方向，Ψ表示相位偏移，σ是高斯包络的sigma(标准差)，<br>
γ决定了Gabor函数形状（support，我翻译为形状）的椭圆率（ellipticity）。当γ= 1时，形状是圆的。当γ< 1时，形状随着平行条纹方向而拉长。通常该值为0.5<br>

翻译自英文维基百科条目SIFT：关键点描述符：<br>
前面的步骤在特定比例上找到关键点位置并为其指定方向。这保证了对图像位置、比例和旋转的不变性。现在，我们要为每个关键点计算一个描述符向量，使得该描述符具有高度的区别性，并且对剩余的变化（例如照明、3D视点等）具有部分的不变性。该步骤在与关键点尺度最接近的图像上执行。

首先在4×4像素的邻域上创建一组方向直方图，每个邻域有8个像素。这些直方图是根据关键点周围16×16区域中样本的大小和方向值来计算的，这样每个直方图都包含来自原始邻域区域的4×4子区域的样本。图像的梯度大小和方向是围绕关键点位置采样的，使用关键点的比例来选择图像的高斯模糊级别。为了实现方向不变性，描述子的坐标和梯度方向相对于关键点方向旋转。梯度(magnitude)进一步由高斯函数加权，σ等于描述符窗口宽度的一半。然后，描述符成为这些直方图的所有值的向量。因为有4×4=16个直方图，每个直方图有8个像素，所以向量有128个元素。然后将该矢量归一化为单位长度，以增强对照明中仿射变化的不变性。为了减少非线性照明的影响，应用0.2的阈值，并再次对矢量进行归一化。阈值处理，也称为钳制，即使在不存在非线性照明效果的情况下，也可以改善匹配结果。通过经验选择阈值0.2，用系统计算的阈值代替固定阈值，可以提高匹配结果。

特征描述子与关键点所在尺度有关，因此对梯度的求取应在特征点对应的高斯图像上进行。将关键点附近划分成d×d个子区域，每个子区域尺寸为mσ个像元（d=4，m=3，σ为尺特征点的尺度值）。考虑到实际计算时需要双线性插值，故计算的图像区域为mσ(d+1)，再考虑旋转

## 机器学习

调参的过程即为“学习”

机器学习之”分类和聚类“与图像处理之“识别与分割”
