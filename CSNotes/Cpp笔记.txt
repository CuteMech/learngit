malloc和new从申请的内存所在位置、返回类型安全性、内存分配失败时的返回值、是否需要指定内存大小这四点区分。
1、申请的内存所在位置不同new操作符从自由存储区（free store）上为对象动态分配内存空间。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。malloc函数从堆上动态分配内存。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
2、返回类型安全性不同new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
3、内存分配失败时的返回值不同new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL。malloc分配内存失败时返回NULL。
4、是否需要指定内存大小不同使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。malloc则需要显式地指出所需内存的尺寸。

函数前置声明的时候，初始化赋值的变量只最前面的前置声明中，在后面的函数实现中不得赋值
C/C++中的显示调用和隐式调用：

（1）、显示调用

             显示调用是指在程序中能找到相应的调用代码，或者说是手动调用的

（2）、隐式调用

             隐式调用是指程序中找不到相应的调用代码，或者说是编译器自动调用的

      类的构造函数与析构函数一般就是隐式调用的。但是，析构函数与构造函数不同，构造函数只能隐式调用，而析构函数可以隐式调用，也可以被显示调用（a.~Sample();）。

      如果程序使用exit或abort非正常退出，则不会隐式调用析构函数，这样就造成对象申请的资源无法回收，从而导致操作系统的资源紧张而使应用程序无法运行。因此，在通常情况下，应使用return语句正常退出。

堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 
堆栈(Stack，亦译作"栈")是一种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。

cin遇到空格tab回车都会结束接受字符串输入 char*
std::ostream_iterator<type>(std::cout, " "));每次写操作后写入""中的分隔字符串。
cctype
isalnum字母数字	isalpha字母	isdigits数字
isspace空白	ispunct该字符是否是标点
decltype(a) b 定义b和a同类型
toupper(s) 返回字符串s的大写(可s[k]只改变其中一个字符), for( auto &c : s)

常对象 常成员函数 友元函数 友元类

深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。
深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。
浅拷贝无需额外写一个
	A(const A& _A) : size(_A.size)
	{
		data = new int[size];
	} // 深拷贝 

继承派生
protected继承比private多一项 派生类的成员函数可以访问当前对象的基类的保护成员
执行派生类构造函数之前, 先执行基类的构造函数；
构造函数名(形参表): 基类名(基类构造函数实参表){}	基类构造函数显式则派生类也要显式

运算操作符重载
const类型间接地不可改变；const类型不可被非const类型的指针指向
labs()长整形取绝对值
赋值运算符重载时，返回值设为其所作用的对象的引用，是符合赋值运算符使用习惯的做法
atoi(str) 将字符串str上的数字变int输出；如果str中的非空白字符的第一个序列不是有效的整数，或者由于str为空或仅包含空白字符而没有这样的序列，则不执行任何转换并返回零。
c.real = atof(sTmp.c_str()); //atof库函数能将const char*指针指向的内容转换成 float

Defined in header <cstring>		
void* memcpy( void* dest, const void* src, std::size_t count );
	
函数模板
C++编译器遵循以下优先顺序:
Step 1: 先找参数完全匹配的普通函数(非由模板实例化而得的函数)
Step 2: 再找参数完全匹配的模板函数
Step 3: 再找实参经过自动类型转换后能够匹配的普通函数
Step 4: 上面的都找不到, 则报错
string特性看下载的PPT

原则：类模板，模板类是类模板的实例
类模板派生出类模板；模板类 (即类模板中类型/非类型参数实例化后的类)派生出类模板
普通类派生出类模板；模板类派生出普通类.
从类模板不可直接派生出普通类，要先产生实例才可
B<char>obj1 为类模板
template<class T>
	class B{ };  的实例化

STL笔记
容器.resize() www.cplusplus.com/reference/vector/vector/resize/
.front()访问“容器”或“迭代器”的“第一个元素”,back()就是访问容器的最后一个元素
1. map、set、list、vector、deque这五种容器中，有几种是排序的？
2种(map和set)
2. 下面5种操作，有几种时间复杂度一定是常数的？2种(O(N))
(1)在vector尾部增删元素√
(2)在关联容器中查找元素 O(log(N))
(3)在list中的某一位置增删元素√
(4)随机访问vector中的元素 (存取才是O(N))
(5)在multimap中插入元素O(log(N))

顺序容器
vector 随机访问
deque 随机访问
list 双向
关联容器
set/multiset 双向
map/multimap 双向

Vector的数据模型就是数组，这点与C完全兼容、高效随机访问、节省空间。但是缺点是内部插入删除元素代价巨大、动态大小超过自身容量需要申请大量内存做大量拷贝。
List 的数据结构模型是链表，任意位置插入删除元素常量时间复杂度、两个容器融合是常量时间复杂度 On，但是不支持随机访问、比vector占用更多的存储空间。
Deque的数据模型是数组和链表的折衷，高效随机访问、内部插入删除元素效率方便、两端push pop，同样内存占用率比较高。
Map、set、multimap、multiset的数据结构模型是二叉树(红黑树)，元素会按照键值排序、查找是对数时间复杂度、通过键值查元素、map提供了下标访问 logn。
如果需要随机访问，用vector，如果存储元素的数目已知，用vector，需要任意位置随机插入删除，用list，只有需要更多在容器的首部尾部插入删除元素，用deque，元素是复杂结构用list，也可以用vector存储指针(需要额外的精力去维护内存)，看需求。，如果操作是基于键值，用set map，如果需要经常的搜索，用map set，同样我们如果最小效率速度，可以利用hash_map，相对于以空间换时间，时间复杂度为O1。

find() 输出迭代器 find在[first,last)查找等于val的元素；找到，则该迭代器指向被找到的元素；找不到，则该迭代器等于last
str.find("+", 0);从下标0开始
string str1 = str.substr(a,b);      // 根据以上两个端位置，保留从第a位开始，共b个字符到字符串str1

先语法，看书，做基本练习
再算法，基本的练到一定程度可以加入竞赛（如力扣）
